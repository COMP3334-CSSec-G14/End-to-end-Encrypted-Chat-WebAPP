<!DOCTYPE html>
<html lang="en">
<!-- 
This software is provided under the BSD License. Copyright (c) 2024 Xavier de CarnÃ© de Carnavalet.
Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the original author is acknowledged. See JavaScript source for full license text.
-->

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat Application</title>
    <!-- Bootstrap CSS for styling -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <!-- Custom CSS -->
    <link href="{{ url_for('static', filename='styles.css') }}" rel="stylesheet">
</head>

<body>
    <div class="container mt-4">
        <h2>Chat Application <small> - (<button onclick="logout()">Logout</button>)</small></h2>
        <div class="chat-box">
            <!-- Chat messages container -->
            <div id="messages"
                style="border:1px solid #ccc; height:300px; margin-bottom:20px; overflow-y:scroll; padding:10px;"></div>
            <!-- User selection dropdown -->
            <select id="userList" class="form-control mb-2">
                <option value="-1" disabled selected><i>Choose a contact</i></option>
                <!-- User options populated here -->
            </select>
            <!-- Message input -->
            <textarea id="messageInput" class="form-control mb-2" placeholder="Type a message..."></textarea>
            <div class="d-flex justify-content-between">
                <button onclick="sendMessage()" class="btn btn-primary">Send</button>
                <div>
                    <button onclick="refreshKeys()" class="btn btn-secondary btn-sm">Refresh Keys</button>
                    <button onclick="eraseChat()" class="btn btn-danger btn-sm">Erase Chat</button>
                </div>
            </div>
        </div>
    </div>

    <!-- jQuery for simplified JavaScript -->
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"
        integrity="sha384-1H217gwSVyLSIfaLxHbE7dRb3v4mYCKbpQvzx0cegeju1MVsGrX5xXxAvs/HgeFs"
        crossorigin="anonymous"></script>
    <script type="text/javascript">
        // Global variables
        let lastMessageId = 0;
        let peer_id = -1;
        const myID = {{ sender_id }};
        let userInfo = {};

        // Ctrl+Enter to send message
        document.addEventListener('DOMContentLoaded', function () {
            document.getElementById('messageInput').addEventListener('keydown', function (e) {
                if (e.ctrlKey && e.key === 'Enter') {
                    sendMessage();
                }
            });
        });

        function logout() {
            localStorage.clear();
            window.location.href = '/logout';
        }

        // Global variables for storing cryptographic keys
        let encryptionKey, decryptionKey;
        let saltCounter = 1;
        let counter = 0;

        async function setupCrypto() {
            if (localStorage.getItem("privateKey")) {
                displayMessage({ message_text: 'Warning: Use local key, not generate new key' });
                return;
            }

            displayMessage({ message_text: 'Warning: No key save in local, generate new key, cannot display previous messages' });
            const { privateKey, publicKey } = await generateECDHKey();

            const salt = window.crypto.getRandomValues(new Uint8Array(16));
            const saltString = btoa(String.fromCharCode.apply(null, salt));
            saltCounter++;
            await sendSaltToServer(saltString);
        }

        window.onload = setupCrypto;

        // Generate ECDH key pair and public key
        async function generateECDHKey() {
            const keyPair = await window.crypto.subtle.generateKey(
                {
                    name: "ECDH",
                    namedCurve: "P-384"
                },
                true,
                ["deriveKey", "deriveBits"]
            );

            const publicKey = await window.crypto.subtle.exportKey("jwk", keyPair.publicKey);
            await saveKeyToLocalStorage(keyPair.privateKey, "privateKey");
            sendPublicKeyToServer(publicKey);

            return { keyPair, publicKey };
        }

        async function deriveHKDFKeys(peerPublicKey, peerid) {
            const privateKey = await getKeyFromLocalStorage("privateKey", 1);

            if (!privateKey) {
                console.error("Private key not found. Please generate key pair first.");
                return;
            }

            const peerSalt = await fetchPeerSalt(peerid);
            let ownSaltArray = localStorage.getItem('salt');
            ownSaltArray = JSON.parse(ownSaltArray)
            const ownSalt = ownSaltArray[ownSaltArray.length - 1];
            console.log("ownSalt", ownSalt);

            const peerSaltUint8Array = base64ToUint8Array(peerSalt);
            const ownSaltUint8Array = base64ToUint8Array(ownSalt);

            const sharedSecret = await window.crypto.subtle.deriveBits(
                {
                    name: "ECDH",
                    public: peerPublicKey
                },
                privateKey,
                384
            );

            const sharedSecretUint8Array = new Uint8Array(sharedSecret);
            const hkdfKey = await window.crypto.subtle.importKey(
                "raw",
                sharedSecretUint8Array,
                { name: "HKDF" },
                false,
                ["deriveKey"]
            );

            // Generate encryption key
            //  - Own Encryption Key
            const ownEncryptionKeyInfo = `CHAT_KEY_${myID}_to_${peerid}`;
            const ownEncryptionKey = await deriveKeyWithHKDF(hkdfKey, privateKey, peerPublicKey, ownSaltUint8Array, ownEncryptionKeyInfo, ["encrypt", "decrypt"]);
            console.log("ownEncryptionKey", ownEncryptionKey);

            //  - Peer Encryption Key
            const peerEncryptionKeyInfo = `CHAT_KEY_${peerid}_to_${myID}`;
            const peerEncryptionKey = await deriveKeyWithHKDF(hkdfKey, privateKey, peerPublicKey, peerSaltUint8Array, peerEncryptionKeyInfo, ["encrypt", "decrypt"]);
            console.log("peerEncryptionKey", peerEncryptionKey);

            // Generate MAC key
            //  - Own Mac Key
            const ownMacKeyInfo = `MAC_KEY_${myID}_to_${peerid}`;
            const ownMacKey = await deriveKeyForSigning(hkdfKey, privateKey, peerPublicKey, ownSaltUint8Array, ownMacKeyInfo, ["sign", "verify"]);
            console.log("ownMacKey", ownMacKey);

            //  - Peer Mac Key
            const peerMacKeyInfo = `MAC_KEY_${peerid}_to_${myID}`;
            const peerMacKey = await deriveKeyForSigning(hkdfKey, privateKey, peerPublicKey, peerSaltUint8Array, peerMacKeyInfo, ["sign", "verify"]);
            console.log("peerMacKey", peerMacKey);
            
            saveKeyToLocalStorage(ownEncryptionKey, "ownEncryptionKey");
            saveKeyToLocalStorage(peerEncryptionKey, "peerEncryptionKey");
            saveKeyToLocalStorage(ownMacKey, "ownMacKey");
            saveKeyToLocalStorage(peerMacKey, "peerMacKey");
        }

        async function deriveKeyWithHKDF(hkdfKey, privateKey, peerPublicKey, salt, info, keyUsage) {
            return await window.crypto.subtle.deriveKey(
                {
                    name: "HKDF",
                    hash: "SHA-256",
                    salt: salt,
                    info: new TextEncoder().encode(info)
                },
                hkdfKey,
                {
                    name: "AES-GCM",
                    length: 256
                },
                true,
                keyUsage
            );
        }

        async function deriveKeyForSigning(hkdfKey, privateKey, peerPublicKey, salt, info, keyUsage) {
            return await window.crypto.subtle.deriveKey(
                {
                    name: "HKDF",
                    hash: "SHA-256",
                    salt: salt,
                    info: new TextEncoder().encode(info)
                },
                hkdfKey,
                {
                    name: "HMAC",
                    hash: { name: "SHA-256" },
                    length: 256
                },
                true,
                keyUsage
            );
        }

        // Function to send the public key to the server
        async function sendPublicKeyToServer(publicKey) {
            const publicKeyString = JSON.stringify(publicKey);
            fetch('/send_public_key', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ public_key: publicKeyString }),
            })
                .then(response => response.json())
                .then(data => console.log(data))
                .catch(error => console.error('Error sending public key:', error));
        }

        // Function to fetch the peer's public key from the server
        async function fetchPeerPublicKey(peerId) {
            const response = await fetch(`/receive_public_key/${peerId}`);
            const data = await response.json();

            if (response.ok) {
                return data.public_key;
            } else {
                console.error('Failed to fetch peer public key:', data.message);
                return null;
            }
        }

        // Function to send the salt to the server
        async function sendSaltToServer(saltString) {
            let saltsArray = [];
            if (localStorage.getItem('salt')) {
                saltsArray = JSON.parse(localStorage.getItem('salt'));
                saltsArray.push(saltString);
                localStorage.setItem('salt', JSON.stringify(saltsArray));
            } else {
                saltsArray.push(saltString);
                localStorage.setItem('salt', JSON.stringify(saltsArray));
            }
            // localStorage.setItem('salt', saltString);

            fetch('/send_salt', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ salt: saltString }),
            })
                .then(response => response.json())
                .then(data => console.log(data))
                .catch(error => console.error('Error sending salt:', error));
        }

        // Function to fetch the peer's salt from the server
        async function fetchPeerSalt(peerId) {
            let peerSaltsArray = [];
            console.log("Peer ID:", peerId)

            const response = await fetch(`/receive_salt/${peerId}`);
            const data = await response.json();

            if (response.ok) {
                console.log("Peer salt:", data.salt)
                // localStorage.setItem('peerSalt', data.salt);
                if (localStorage.getItem('peerSalt')) {
                    peerSaltsArray = JSON.parse(localStorage.getItem('peerSalt'));
                    if (data.salt !== peerSaltsArray[peerSaltsArray.length - 1]) {
                        peerSaltsArray.push(data.salt);
                        localStorage.setItem('peerSalt', JSON.stringify(peerSaltsArray));
                    }
                } else {
                    peerSaltsArray.push(data.salt);
                    localStorage.setItem('peerSalt', JSON.stringify(peerSaltsArray));
                }
                return data.salt;
            } else {
                console.error('Failed to fetch peer salt:', data.message);
                return null;
            }
        }

        // Handle user selection change
        document.getElementById('userList').addEventListener('change', async event => {
            peer_id = parseInt(event.target.value, 10);
            clearChatBox();
            lastMessageId = 0;
            const peerPublicKeyString = await fetchPeerPublicKey(peer_id);

            if (peerPublicKeyString) {
                const peerPublicKey = await window.crypto.subtle.importKey(
                    "jwk",
                    JSON.parse(peerPublicKeyString),
                    {
                        name: "ECDH",
                        namedCurve: "P-384"
                    },
                    true,
                    []
                );
                console.log("peerPublicKeyString", peerPublicKeyString);
                if (localStorage.getItem("peerEncryptionKey") &&
                    localStorage.getItem("peerMacKey") &&
                    localStorage.getItem("ownEncryptionKey") &&
                    localStorage.getItem("ownMacKey")
                ) {
                    displayMessage({ message_text: 'Keys already exist' });
                } else {
                    await deriveHKDFKeys(peerPublicKey, peer_id);
                }
            }
            fetchMessages();
        });

        async function saveKeyToLocalStorage(key, keyName) {
            try {
                const exportedKey = await window.crypto.subtle.exportKey("jwk", key);
                let keyString = JSON.stringify(exportedKey);
                if (keyName === "peerEncryptionKey" ||
                    keyName === "peerMacKey" ||
                    keyName === "ownEncryptionKey" ||
                    keyName === "ownMacKey"
                ) {
                    keyString = btoa(keyString);

                    let array = [];
                    if (localStorage.getItem(keyName)) {
                        array = JSON.parse(localStorage.getItem(keyName));
                        if (array[array.length - 1] === keyString) return;
                        array.push(keyString);
                        localStorage.setItem(keyName, JSON.stringify(array));
                    } else {
                        array.push(keyString);
                        localStorage.setItem(keyName, JSON.stringify(array));
                    }
                } else {
                    localStorage.setItem(keyName, keyString);
                }
            } catch (err) {
                console.error("Error exporting key:", err);
            }
        }

        function getKeyFromLocalStorage(keyName, position) {
            let keyString = localStorage.getItem(keyName);
            if (keyName === "peerEncryptionKey" ||
                keyName === "peerMacKey" ||
                keyName === "ownEncryptionKey" ||
                keyName === "ownMacKey"
            ) {
                let array = localStorage.getItem(keyName);
                array = JSON.parse(array)
                keyString = array[array.length - position];
                keyString = atob(keyString);
            }

            if (!keyString) return null;
            console.log("getKeyFromLocalStorage (String): ", keyString);

            const keyObj = JSON.parse(keyString);
            console.log("getKeyFromLocalStorage (Object): ", keyObj);

            if (keyObj.kty === "EC") {
                return window.crypto.subtle.importKey(
                    "jwk",
                    keyObj,
                    {
                        name: "ECDH",
                        namedCurve: "P-384"
                    },
                    true,
                    ["deriveKey", "deriveBits"]
                );
            }
            if (keyObj.alg === "A256GCM") {
                return window.crypto.subtle.importKey(
                    "jwk",
                    keyObj,
                    keyObj.alg.startsWith("A") ? { name: "AES-GCM" } : { name: "HMAC", hash: "SHA-256" },
                    true,
                    keyObj.alg.startsWith("A") ? ["encrypt", "decrypt"] : ["sign", "verify"]
                );
            }

            if (keyObj.kty === "oct") {
                const base64 = keyObj.k.replace(/-/g, '+').replace(/_/g, '/');
                console.log("getKeyFromLocalStorage (base64): ", base64);
                const keyBuffer = Uint8Array.from(atob(base64), c => c.charCodeAt(0)).buffer;

                console.log("getKeyFromLocalStorage (ArrayBuffer): ", keyBuffer);

                return window.crypto.subtle.importKey(
                    "raw",
                    keyBuffer,
                    { name: "HMAC", hash: { name: "SHA-256" } },
                    true,
                    ["sign", "verify"]
                );
            }
        }

        function generateTimeBasedIV() {
            let iv = window.crypto.getRandomValues(new Uint8Array(12));
            let currentTimeStamp = Date.now();

            for (let i = 0; i < 4; i++) {
                iv[i] = (currentTimeStamp >> (8 * i)) & 0xFF;
            }

            return iv;
        }

        // Function to encrypt messages
        async function encryptMessage(plaintext, peer_id, iv) {
            const encryptionKey = await getKeyFromLocalStorage("ownEncryptionKey", 1);
            if (plaintext === 'change') {
                const oldMacKey = await getKeyFromLocalStorage("ownMacKey", 2); 
                const oldHmacIVSignature = await window.crypto.subtle.sign(
                    "HMAC",
                    oldMacKey,
                    iv
                );

                const newMacKey = await getKeyFromLocalStorage("ownMacKey", 1);
                const newHmacIVSignature = await window.crypto.subtle.sign(
                    "HMAC",
                    newMacKey,
                    iv
                );

                const oldHmacHashUint8Array = new Uint8Array(oldHmacIVSignature);
                const newHmacHashUint8Array = new Uint8Array(newHmacIVSignature);
                const newHmacHashBase64 = btoa(String.fromCharCode.apply(null, newHmacHashUint8Array));

                const oldEncryptionKey = await getKeyFromLocalStorage("ownEncryptionKey", 2);
                const encryptedContent = await window.crypto.subtle.encrypt(
                    {
                        name: "AES-GCM",
                        iv: iv,
                        additionalData: new TextEncoder().encode(`CHAT_MSG_${myID}_to_${peer_id}`),
                        tagLength: 128
                    },
                    oldEncryptionKey,
                    new TextEncoder().encode(
                        JSON.stringify({
                            command: "change",
                            newHmac: newHmacHashBase64
                        })
                    )
                );

                return { encryptedContent, iv, oldHmacHashUint8Array };
            }

            const macKey = await getKeyFromLocalStorage("ownMacKey", 1);

            console.log('mackey:', macKey)

            const hmacIVSignature = await window.crypto.subtle.sign(
                "HMAC",
                macKey,
                iv
            );
            console.log('HMAC signature:', hmacIVSignature)

            const hmacHashUint8Array = new Uint8Array(hmacIVSignature);
            const encryptedContent = await window.crypto.subtle.encrypt(
                {
                    name: "AES-GCM",
                    iv: iv,
                    additionalData: new TextEncoder().encode(`CHAT_MSG_${myID}_to_${peer_id}`),
                    tagLength: 128
                },
                encryptionKey,
                new TextEncoder().encode(plaintext)
            );

            return { encryptedContent, iv, hmacHashUint8Array };
        }

        // Function to decrypt messages
        async function decryptMessage(msgSenderId, peer_id, ciphertext, iv) {
            console.log(myID, msgSenderId, peer_id);
            let decryptionKey = null;
            let additionalDataInfo = "";
            let ownEncryptionKeysArray = JSON.parse(localStorage.getItem("ownEncryptionKey"));
            let peerEncryptionKeysArray = JSON.parse(localStorage.getItem("peerEncryptionKey"));

            if (msgSenderId == myID) {
                for (let i = 0; i < ownEncryptionKeysArray.length; i++) {
                    let ownEncryptionKeyString = ownEncryptionKeysArray[ownEncryptionKeysArray.length - 1 - i];
                    try {
                        if (ciphertext.split('.')[0] === 'change') {
                            ownEncryptionKeyString = ownEncryptionKeysArray[ownEncryptionKeysArray.length - 2];
                        } else {
                            ownEncryptionKeyString = ownEncryptionKeysArray[ownEncryptionKeysArray.length - 1];
                        }
                    } catch(error) {
                        ciphertext = btoa(String.fromCharCode.apply(null, new Uint8Array(ciphertext)));
                        ownEncryptionKeyString = ownEncryptionKeysArray[ownEncryptionKeysArray.length - 1 - i];
                        console.log("ownEncryptionKeyString - for error: ", ownEncryptionKeyString);
                    }
                    
                    decryptionKey = atob(ownEncryptionKeyString);
                    additionalDataInfo = `CHAT_MSG_${myID}_to_${peer_id}`;
                    
                    console.log('Decryption key:', decryptionKey);
                    if (ciphertext.split('.')[0] === 'change') {
                        console.log('test1:', ciphertext);
                        ciphertext = base64ToUint8Array(ciphertext.split('.')[1]).buffer;

                        const decryptKey = await window.crypto.subtle.importKey(
                            "jwk",
                            JSON.parse(decryptionKey),
                            {
                                name: "AES-GCM",
                                iv: iv
                            },
                            false,
                            ["decrypt"]
                        );

                        const decryptedContent = await window.crypto.subtle.decrypt(
                            {
                                name: "AES-GCM",
                                iv: iv,
                                additionalData: new TextEncoder().encode(additionalDataInfo),
                                tagLength: 128
                            },
                            decryptKey,
                            ciphertext
                        );

                        console.log("test1");
                        const decryptedContentString = new TextDecoder().decode(decryptedContent);
                        const decryptedContentJson = JSON.parse(decryptedContentString);
                        console.log(decryptedContentJson);
                        console.log(decryptedContentJson.command);
                        if (decryptedContentJson.command === 'change') {
                            if (myID == msgSenderId) {
                                return 'Warning: Key Changed !!!';
                            }
                            const newHmacHashBase64 = decryptedContentJson.newHmac;

                            const peerPublicKeyString = await fetchPeerPublicKey(msgSenderId);
                            if (peerPublicKeyString) {
                                const peerPublicKey = await window.crypto.subtle.importKey(
                                    "jwk",
                                    JSON.parse(peerPublicKeyString),
                                    {
                                        name: "ECDH",
                                        namedCurve: "P-384"
                                    },
                                    true,
                                    []
                                );
                                await deriveHKDFKeys(peerPublicKey, msgSenderId);
                            }
                            console.log(await changeKeyMessageVerify(newHmacHashBase64, iv, peer_id));
                            if (await changeKeyMessageVerify(newHmacHashBase64, iv, peer_id)) {
                                return 'Warning: Key Changed !!!';
                            }
                        }
                    } else {
                        try {
                            console.log('Own Msg Test2:', ciphertext);
                            ciphertext = base64ToUint8Array(ciphertext).buffer;

                            const decryptKey = await window.crypto.subtle.importKey(
                                "jwk",
                                JSON.parse(decryptionKey),
                                {
                                    name: "AES-GCM",
                                    iv: iv
                                },
                                false,
                                ["decrypt"]
                            );
                            
                            const decryptedContent = await window.crypto.subtle.decrypt(
                                {
                                    name: "AES-GCM",
                                    iv: iv,
                                    additionalData: new TextEncoder().encode(additionalDataInfo),
                                    tagLength: 128
                                },
                                decryptKey,
                                ciphertext
                            );

                            console.log('Own Decrypted content:', new TextDecoder().decode(decryptedContent));
                            return new TextDecoder().decode(decryptedContent);
                        } catch (error) {
                            console.log(error);
                            continue;
                        }
                    }
                }
            } else {
                let changeKeyMsgFlag = false;
                for (let i = 0; i < peerEncryptionKeysArray.length; i++) {
                    try {
                        peerEncryptionKeyString = peerEncryptionKeysArray[peerEncryptionKeysArray.length - i - 1];
                        console.log(peerEncryptionKeyString);
                    } catch(err) {
                        console.log(err);
                        console.log("Peer ciphertext !", ciphertext);
                        ciphertext = btoa(String.fromCharCode.apply(null, new Uint8Array(ciphertext)));
                        console.log("ciphertext - for error: ", ciphertext);
                        peerEncryptionKeyString = peerEncryptionKeysArray[peerEncryptionKeysArray.length - 1 - i];
                        console.log("peerEncryptionKeyString - for error: ", peerEncryptionKeysArray);
                    }

                    decryptionKey = atob(peerEncryptionKeyString);
                    additionalDataInfo = `CHAT_MSG_${msgSenderId}_to_${myID}`;
                    
                    console.log('Decryption key:', decryptionKey);
                    
                    try {
                        if (ciphertext.split('.')[0] === 'change') {
                            changeKeyMsgFlag = true;
                        }
                    } catch (error) {
                        changeKeyMsgFlag = false;
                    }
                    
                    if (changeKeyMsgFlag) {
                        console.log('test1:', ciphertext);
                        ciphertext = base64ToUint8Array(ciphertext.split('.')[1]).buffer;

                        const decryptKey = await window.crypto.subtle.importKey(
                            "jwk",
                            JSON.parse(decryptionKey),
                            {
                                name: "AES-GCM",
                                iv: iv
                            },
                            false,
                            ["decrypt"]
                        );

                        const decryptedContent = await window.crypto.subtle.decrypt(
                            {
                                name: "AES-GCM",
                                iv: iv,
                                additionalData: new TextEncoder().encode(additionalDataInfo),
                                tagLength: 128
                            },
                            decryptKey,
                            ciphertext
                        );

                        console.log("test1");
                        const decryptedContentString = new TextDecoder().decode(decryptedContent);
                        const decryptedContentJson = JSON.parse(decryptedContentString);
                        console.log(decryptedContentJson);
                        console.log(decryptedContentJson.command);
                        if (decryptedContentJson.command === 'change') {
                            if (myID == msgSenderId) {
                                return 'Warning: Key Changed !!!';
                            }
                            const newHmacHashBase64 = decryptedContentJson.newHmac;

                            const peerPublicKeyString = await fetchPeerPublicKey(msgSenderId);
                            if (peerPublicKeyString) {
                                const peerPublicKey = await window.crypto.subtle.importKey(
                                    "jwk",
                                    JSON.parse(peerPublicKeyString),
                                    {
                                        name: "ECDH",
                                        namedCurve: "P-384"
                                    },
                                    true,
                                    []
                                );
                                await deriveHKDFKeys(peerPublicKey, msgSenderId);
                            }
                            console.log(await changeKeyMessageVerify(newHmacHashBase64, iv, peer_id));
                            if (await changeKeyMessageVerify(newHmacHashBase64, iv, peer_id)) {
                                return 'Warning: Key Changed !!!';
                            }
                        }
                    } else if (!changeKeyMsgFlag) {
                        try {
                            if (typeof ciphertext === 'string') {
                                console.log('Peer Msg Test1:', ciphertext);
                                ciphertext = base64ToUint8Array(ciphertext).buffer;
                            } else {
                                console.log('Peer Msg Test2:', ciphertext);
                            }

                            const decryptKey = await window.crypto.subtle.importKey(
                                "jwk",
                                JSON.parse(decryptionKey),
                                {
                                    name: "AES-GCM",
                                    iv: iv
                                },
                                false,
                                ["decrypt"]
                            );

                            const decryptedContent = await window.crypto.subtle.decrypt(
                                {
                                    name: "AES-GCM",
                                    iv: iv,
                                    additionalData: new TextEncoder().encode(additionalDataInfo),
                                    tagLength: 128
                                },
                                decryptKey,
                                ciphertext
                            );

                            console.log('Peer Decrypted content:', new TextDecoder().decode(decryptedContent));
                            return new TextDecoder().decode(decryptedContent);
                        } catch (error) {
                            console.log(error);
                            continue;
                        }
                    }
                }
            }
        }

        async function changeKeyMessageVerify(newHmacHashBase64, decodedIv, peer_id) {
            const newHmacHashUint8Array = base64ToUint8Array(newHmacHashBase64);

            const macKey = await getKeyFromLocalStorage("peerMacKey", 1);

            const hmac = await window.crypto.subtle.sign(
                { name: "HMAC" },
                macKey,
                decodedIv
            );

            receivedHmacBuffer = newHmacHashUint8Array.buffer;

            return window.crypto.subtle.verify(
                "HMAC",
                macKey,
                receivedHmacBuffer,
                decodedIv
            );
        }

        // Send message function
        async function sendMessage() {
            if (peer_id == -1) return;
            const message = document.getElementById('messageInput').value;

            // Encrypt the message before sending
            const iv = generateTimeBasedIV();
            const { encryptedContent, hmacHashUint8Array } = await encryptMessage(message, peer_id, iv);

            // Convert ArrayBuffer to base64
            const encryptedMessage = btoa(String.fromCharCode.apply(null, new Uint8Array(encryptedContent)));
            const base64IV = btoa(String.fromCharCode.apply(null, iv));
            localStorage.setItem('ownlastBase64IV', base64IV);
            const base64HMAC = btoa(String.fromCharCode.apply(null, hmacHashUint8Array));

            const payload = {
                receiver_id: peer_id,
                message_text: encryptedMessage,
                iv: base64IV,
                hmac: base64HMAC,
            };

            fetch('/send_message', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(payload),
            })
                .then(response => {
                    if (!response.ok) {
                        // If the server response is not OK, throw an error
                        throw new Error('Network response was not ok');
                    }
                    return response.json(); // Parse JSON response from the server
                })
                .then(data => {
                    document.getElementById('messageInput').value = ''; // Clear the input after sending
                })
                .catch(error => {
                    console.error('Error sending message:', error); // Log any errors
                });
        }

        // Refresh Keys function placeholder
        async function refreshKeys() {
            if (peer_id === -1) return;

            // Generate new salt
            const newSalt = window.crypto.getRandomValues(new Uint8Array(16));
            const newSaltString = btoa(String.fromCharCode.apply(null, newSalt));
            await sendSaltToServer(newSaltString);

            // Re-derive all symmetric keys with new salt
            const peerPublicKeyString = await fetchPeerPublicKey(peer_id);
            const peerPublicKey = await window.crypto.subtle.importKey(
                "jwk",
                JSON.parse(peerPublicKeyString),
                {
                    name: "ECDH",
                    namedCurve: "P-384"
                },
                true,
                []
            );

            await deriveHKDFKeys(peerPublicKey, peer_id);

            // Retrieve the last IV used from localStorage
            const ownlastBase64IV = localStorage.getItem('ownlastBase64IV');
            if (!ownlastBase64IV) {
                console.error('No last IV found. Cannot send key change message.');
                return;
            }
            const ownlastIVUint8Array = base64ToUint8Array(ownlastBase64IV);

            keyChangeMessage = "change";

            // Encrypt and sign the key change message with both old and new MAC keys
            const { encryptedContent, iv, oldHmacHashUint8Array } = await encryptMessage(keyChangeMessage, peer_id, ownlastIVUint8Array);

            await sendKeyChangeMessage(encryptedContent, iv, oldHmacHashUint8Array);

            // displayMessage({ message_text: `Key Changed & Change message sent successfully` });
        }

        async function sendKeyChangeMessage(encryptedContent, iv, oldMacSignature) {
            // Convert the key & IV & HMAC from ArrayBuffer to base64
            const encryptedMessageBase64 = arrayBufferToBase64(encryptedContent);
            const ivBase64 = arrayBufferToBase64(iv);
            const oldMacSignatureBase64 = arrayBufferToBase64(oldMacSignature);

            const payload = {
                receiver_id: peer_id,
                message_text: "change." + encryptedMessageBase64,
                iv: ivBase64,
                hmac: oldMacSignatureBase64,
            };

            fetch('/send_message', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(payload),
            })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Failed to send key change message to the server');
                    }
                    console.log('Key change message sent successfully');
                })
                .catch(error => {
                    console.error('Error sending key change message:', error);
                });
        }

        function arrayBufferToBase64(buffer) {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return window.btoa(binary);
        }


        // Populate users function
        function populateUsers(users) {
            const userListDropdown = document.getElementById("userList");
            users.forEach(user => {
                const option = new Option(user[1], user[0]); // username as text, user_id as value
                userListDropdown.add(option);
            });
        }

        // Fetch users from server
        $(document).ready(function () {
            fetch('/users')
                .then(response => response.json())
                .then(data => {
                    data.users.forEach(user => {
                        userInfo[user[0]] = user[1]; // Map user_id to username
                    });
                    console.log(userInfo);
                    populateUsers(data.users);
                })
                .catch(error => console.error('Error fetching user info:', error));
        });

        // Clear chat box
        function clearChatBox() {
            document.getElementById('messages').innerHTML = '';
        }

        // Fetch messages from server
        function fetchMessages() {
            if (peer_id === -1) return; // Exit if no peer selected

            fetch(`/fetch_messages?last_message_id=${lastMessageId}&peer_id=${peer_id}`)
                .then(response => response.json())
                .then(data => {
                    data.messages.forEach(message => {
                        if (typeof message.message_text === 'undefined' || typeof message.iv === 'undefined') {
                            console.error('Undefined message text or iv');
                            return;
                        }

                        try {
                            const decodedIv = base64ToUint8Array(message.iv);
                            const decodedHMAC = base64ToUint8Array(message.hmac);

                            if (message.sender_id !== myID) {

                                verifyIV(message.iv, decodedHMAC)
                                    .then(isValid => {
                                        if (!isValid) {
                                            console.error('IV verification failed');
                                            return;
                                        }
                                        localStorage.setItem('peerlastBase64IV', message.iv);

                                        console.log("Before Decrypt msg:", message.message_text);
                                        decryptMessage(message.sender_id, message.receiver_id, message.message_text, decodedIv)
                                            .then(decryptedMessage => {
                                                message.message_text = decryptedMessage;
                                                displayMessage(message);
                                            })
                                            .catch(error => console.error('Error decrypting message:', error));
                                    })
                                    .catch(error => console.error('Error verifying HMAC:', error));
                            } else {
                                decryptMessage(message.sender_id, message.receiver_id, message.message_text, decodedIv)
                                    .then(decryptedMessage => {
                                        message.message_text = decryptedMessage;
                                        displayMessage(message);
                                    })
                                    .catch(error => console.error('Error decrypting message:', error));
                            }
                        } catch (error) {
                            console.error('Error decoding base64:', error);
                        }
                        lastMessageId = message.message_id;
                    });
                })
                .catch(error => console.error('Error fetching messages:', error));
        }

        async function verifyIV(iv, receivedHmac) {
            const decodedIv = base64ToUint8Array(iv);

            const decodedIvForComparison = base64ToUint8Array(iv.substring(4));
            // if peerlastBase64IV is not set, then this is the first message
            if (localStorage.getItem('peerlastBase64IV')) {
                // As a recipient, verify that IVi > IVi-1 to prevent replay attacks
                const lastBase64IV = localStorage.getItem('peerlastBase64IV');
                const lastIVForComparison = base64ToUint8Array(lastBase64IV.substring(5));
                const lastIV = base64ToUint8Array(lastBase64IV);
                const ivValue = byteArrayToBigInt(decodedIvForComparison);
                const lastIVValue = byteArrayToBigInt(lastIVForComparison);

                if (ivValue <= lastIVValue) {
                    console.error('IV value is not greater than the last IV');
                    return false;
                }
            }

            // const macKeyJwkString = atob(localStorage.getItem('peerMacKey'));
            let peerMacKeysArray = localStorage.getItem('peerMacKey');
            peerMacKeysArray = JSON.parse(peerMacKeysArray)
            let flag = false;
            for (let i = 0; i < peerMacKeysArray.length; i++) {
                const macKeyJwkString = atob(peerMacKeysArray[peerMacKeysArray.length - i - 1]);
                const macKeyJwk = JSON.parse(macKeyJwkString);

                const macKey = await window.crypto.subtle.importKey(
                    'jwk',
                    macKeyJwk,
                    {
                        name: 'HMAC',
                        hash: { name: 'SHA-256' }
                    },
                    false,
                    ['sign', 'verify']
                );

                const hmac = await window.crypto.subtle.sign(
                    { name: "HMAC" },
                    macKey,
                    decodedIv
                );

                let receivedHmacBuffer;
                if (receivedHmac instanceof ArrayBuffer) {
                    receivedHmacBuffer = receivedHmac;
                } else {
                    receivedHmacBuffer = new Uint8Array(receivedHmac).buffer;
                }

                flag = window.crypto.subtle.verify(
                    "HMAC",
                    macKey,
                    receivedHmacBuffer,
                    decodedIv
                );
                console.log('flag:', flag);
                if (flag) {
                    break;
                }
            }
            if (!flag) {
                console.error('HMAC verification failed');
                return false;
            }
            return true;
        }

        function byteArrayToBigInt(byteArray) {
            let value = BigInt(0);
            for (let i = 0; i < byteArray.length; i++) {
                value = (value * BigInt(256)) + BigInt(byteArray[i]);
            }
            return value;
        }

        function base64ToUint8Array(base64) {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            let bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes;
        }

        // Display a single message
        function displayMessage(message) {
            const messagesContainer = document.getElementById('messages');
            const messageElement = document.createElement('div');

            // Determine sender and receiver strings
            const sender = message.sender_id == myID ? "me" : (userInfo[message.sender_id] || `User ${message.sender_id}`);
            const receiver = message.receiver_id == myID ? "me" : (userInfo[message.receiver_id] || `User ${message.receiver_id}`);

            if (message.message_text === 'Warning: Use local key, not generate new key' ||
                message.message_text === 'Warning: No key save in local, generate new key, cannot display previous messages' ||
                message.message_text === 'Keys already exist' ||
                message.message_text === 'Warning: Key Changed !!!'
            ) {
                messageElement.textContent = message.message_text;
                messagesContainer.appendChild(messageElement);
                return;
            }
            messageElement.textContent = `From ${sender} to ${receiver}: ${message.message_text}`;
            messagesContainer.appendChild(messageElement);
        }

        // Periodically fetch new messages every second
        setInterval(fetchMessages, 1000);

        // Erase Chat function using fetch API
        function eraseChat() {
            if (peer_id === -1) return; // Exit if no peer selected
            if (!confirm('Are you sure you want to erase the chat with ' + userInfo[peer_id] + '?')) return; // Confirmation before erasing

            fetch(`/erase_chat`, {
                method: 'POST',  // A REST API should use POST if it leads to modifications
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ peer_id: peer_id })
            })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json(); // Assuming the server responds with JSON
                })
                .then(data => {
                    console.log('Chat erased:', data);
                    clearChatBox(); // Clear the chat display
                })
                .catch(error => {
                    console.error('Error erasing chat:', error);
                });
        }

    </script>
</body>

</html>