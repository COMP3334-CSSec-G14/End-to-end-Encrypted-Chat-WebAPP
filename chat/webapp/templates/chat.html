<!DOCTYPE html>
<html lang="en">
<!-- 
This software is provided under the BSD License. Copyright (c) 2024 Xavier de CarnÃ© de Carnavalet.
Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the original author is acknowledged. See JavaScript source for full license text.
-->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat Application</title>
    <!-- Bootstrap CSS for styling -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <!-- Custom CSS -->
    <link href="{{ url_for('static', filename='styles.css') }}" rel="stylesheet">
</head>
<body>
<div class="container mt-4">
    <h2>Chat Application <small> - (<button onclick="logout()">Logout</button>)</small></h2>
    <div class="chat-box">
        <!-- Chat messages container -->
        <div id="messages" style="border:1px solid #ccc; height:300px; margin-bottom:20px; overflow-y:scroll; padding:10px;"></div>
        <!-- User selection dropdown -->
        <select id="userList" class="form-control mb-2">
            <option value="-1" disabled selected><i>Choose a contact</i></option>
            <!-- User options populated here -->
        </select>
        <!-- Message input -->
        <textarea id="messageInput" class="form-control mb-2" placeholder="Type a message..."></textarea>
        <div class="d-flex justify-content-between">
            <button onclick="sendMessage()" class="btn btn-primary">Send</button>
            <div>
                <button onclick="refreshKeys()" class="btn btn-secondary btn-sm">Refresh Keys</button>
                <button onclick="eraseChat()" class="btn btn-danger btn-sm">Erase Chat</button>
            </div>
        </div>
    </div>
</div>

<!-- jQuery for simplified JavaScript -->
<script src="https://code.jquery.com/jquery-3.7.1.min.js" integrity="sha384-1H217gwSVyLSIfaLxHbE7dRb3v4mYCKbpQvzx0cegeju1MVsGrX5xXxAvs/HgeFs" crossorigin="anonymous"></script>
<script type="text/javascript">
// Global variables
let lastMessageId = 0;
let peer_id = -1;
const myID = {{ sender_id }};
let userInfo = {};

// Ctrl+Enter to send message
document.addEventListener('DOMContentLoaded', function() {
    document.getElementById('messageInput').addEventListener('keydown', function(e) {
        if (e.ctrlKey && e.key === 'Enter') {
            sendMessage();
        }
    });
});

function logout() {
    localStorage.clear();
    window.location.href = '/logout';
}

// Global variables for storing cryptographic keys
let encryptionKey, decryptionKey;
let saltCounter = 1;

async function setupCrypto() {
    const { privateKey, publicKey } = await generateECDHKey();
}

window.onload = setupCrypto;

// Generate ECDH key pair and public key
async function generateECDHKey() {
    const keyPair = await window.crypto.subtle.generateKey(
        {
            name: "ECDH",
            namedCurve: "P-384"
        },
        true,
        ["deriveKey", "deriveBits"]
    );

    const publicKey = await window.crypto.subtle.exportKey("jwk", keyPair.publicKey);
    await saveKeyToLocalStorage(keyPair.privateKey, "privateKey");
    sendPublicKeyToServer(publicKey);

    return { keyPair, publicKey };
}

async function deriveHKDFKeys(peerPublicKey, peerid) {
    const privateKey = await getKeyFromLocalStorage("privateKey");

    if (!privateKey) {
        console.error("Private key not found. Please generate key pair first.");
        return;
    }
    
    const salt = window.crypto.getRandomValues(new Uint8Array(16));

    saltCounter++;
    const encryptionKeyInfo = `CHAT_KEY_TO_${peerid}`;
    const encryptionKey = await deriveKeyWithHKDF(privateKey, peerPublicKey, salt, encryptionKeyInfo, ["encrypt", "decrypt"]);
    console.log("encryptionKey", encryptionKey);

    const macKeyInfo = `MAC_KEY_TO_${peerid}`;
    const macKey = await deriveKeyForSigning(privateKey, peerPublicKey, salt, macKeyInfo, ["sign", "verify"]);
    console.log("macKey", macKey);

    saveKeyToLocalStorage(encryptionKey, "encryptionKey");
    saveKeyToLocalStorage(macKey, "macKey");
}

async function deriveKeyWithHKDF(privateKey, peerPublicKey, salt, info, keyUsage) {
    return await window.crypto.subtle.deriveKey(
        {
            name: "ECDH",
            public: peerPublicKey,
            hash: "SHA-256",
            salt: salt,
            info: new TextEncoder().encode(info)
        },
        privateKey,
        {
            name: "AES-GCM",
            length: 256
        },
        true,
        keyUsage
    );
}

async function deriveKeyForSigning(privateKey, peerPublicKey, salt, info, keyUsage) {
    const sharedSecret = await window.crypto.subtle.deriveBits(
        {
            name: "ECDH",
            public: peerPublicKey
        },
        privateKey,
        384
    );

    const sharedSecretUint8Array = new Uint8Array(sharedSecret);
    
    const hkdfKey = await window.crypto.subtle.importKey(
        "raw",
        sharedSecretUint8Array,
        { name: "HKDF" },
        false,
        ["deriveKey"]
    );

    return await window.crypto.subtle.deriveKey(
        {
            name: "HKDF",
            hash: "SHA-256",
            salt: salt,
            info: new TextEncoder().encode(info)
        },
        hkdfKey,
        {
            name: "HMAC",
            hash: {name: "SHA-256"},
            length: 256
        },
        true,
        keyUsage
    );
}

// Function to send the public key to the server
async function sendPublicKeyToServer(publicKey) {
    const publicKeyString = JSON.stringify(publicKey);
    fetch('/send_public_key', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({public_key: publicKeyString}),
    })
    .then(response => response.json())
    .then(data => console.log(data))
    .catch(error => console.error('Error sending public key:', error));
}

// Function to fetch the peer's public key from the server
async function fetchPeerPublicKey(peerId) {
    const response = await fetch(`/receive_public_key/${peerId}`);
    const data = await response.json();

    if (response.ok) {
        return data.public_key;
    } else {
        console.error('Failed to fetch peer public key:', data.message);
        return null;
    }
}

// Handle user selection change
document.getElementById('userList').addEventListener('change', async event => {
    peer_id = parseInt(event.target.value, 10);
    clearChatBox();
    lastMessageId = 0;
    const peerPublicKeyString = await fetchPeerPublicKey(peer_id);

    if (peerPublicKeyString) {
        const peerPublicKey = await window.crypto.subtle.importKey(
            "jwk",
            JSON.parse(peerPublicKeyString),
            {
                name: "ECDH",
                namedCurve: "P-384"
            },
            true,
            []
        );
        console.log("peerPublicKeyString", peerPublicKeyString);
        await deriveHKDFKeys(peerPublicKey, peer_id);
    }
    fetchMessages();
});

async function saveKeyToLocalStorage(key, keyName) {
    try {
        const exportedKey = await window.crypto.subtle.exportKey("jwk", key);
        const keyString = JSON.stringify(exportedKey);
        localStorage.setItem(keyName, keyString);
    } catch (err) {
        console.error("Error exporting key:", err);
    }
}

function getKeyFromLocalStorage(keyName) {
    const keyString = localStorage.getItem(keyName);
    if (!keyString) return null;
    console.log("getKeyFromLocalStorage (String): ", keyString);

    const keyObj = JSON.parse(keyString);
    console.log("getKeyFromLocalStorage (Object): ", keyObj);

    if (keyObj.kty === "EC") {
        return window.crypto.subtle.importKey(
            "jwk",
            keyObj,
            {
                name: "ECDH",
                namedCurve: "P-384"
            },
            true,
            ["deriveKey", "deriveBits"]
        );
    }
    if (keyObj.alg === "A256GCM") {
        return window.crypto.subtle.importKey(
            "jwk",
            keyObj,
            keyObj.alg.startsWith("A") ? {name: "AES-GCM"} : {name: "HMAC", hash: "SHA-256"},
            true,
            keyObj.alg.startsWith("A") ? ["encrypt", "decrypt"] : ["sign", "verify"]
        );
    }

    if (keyObj.kty === "oct") {
        const base64 = keyObj.k.replace(/-/g, '+').replace(/_/g, '/');
        console.log("getKeyFromLocalStorage (base64): ", base64);
        // Decode base64 to ArrayBuffer
        const keyBuffer = Uint8Array.from(atob(base64), c => c.charCodeAt(0)).buffer;

        console.log("getKeyFromLocalStorage (ArrayBuffer): ", keyBuffer);

        return window.crypto.subtle.importKey(
            "raw",
            keyBuffer, // Use the ArrayBuffer here
            {name: "HMAC", hash: {name: "SHA-256"}},
            true,
            ["sign", "verify"]
        );
    }
}


// Function to encrypt messages
async function encryptMessage(plaintext) {
    const iv = window.crypto.getRandomValues(new Uint8Array(12));
    const encryptionKey = await getKeyFromLocalStorage("encryptionKey");
    const macKey = await getKeyFromLocalStorage("macKey");

    console.log('mackey:', macKey)

    const encoder = new TextEncoder();
    const plaintextBuffer = encoder.encode(plaintext);

    const hmacMsgSignature = await window.crypto.subtle.sign(
        "HMAC",
        macKey,
        plaintextBuffer
    );

    console.log('HMAC signature:', hmacMsgSignature)

    const hmacHashUint8Array = new Uint8Array(hmacMsgSignature);

    const encryptedContent = await window.crypto.subtle.encrypt(
        {
            name: "AES-GCM",
            iv: iv
        },
        encryptionKey,
        new TextEncoder().encode(plaintext)
    );

    return { encryptedContent, iv, hmacHashUint8Array };
}

// Function to decrypt messages
async function decryptMessage(ciphertext, iv) {
    const decryptionKey = await getKeyFromLocalStorage("encryptionKey");

    const decryptedContent = await window.crypto.subtle.decrypt(
        {
            name: "AES-GCM",
            iv: iv,
        },
        decryptionKey,
        ciphertext
    );

    console.log('Decrypted content:', new TextDecoder().decode(decryptedContent));
    return new TextDecoder().decode(decryptedContent);
}

// Send message function
async function sendMessage() {
    if (peer_id == -1) return;
    const message = document.getElementById('messageInput').value;
    
    // Encrypt the message before sending
    const { encryptedContent, iv, hmacHashUint8Array } = await encryptMessage(message);
    
    // Convert ArrayBuffer to base64
    const encryptedMessage = btoa(String.fromCharCode.apply(null, new Uint8Array(encryptedContent)));
    const base64IV = btoa(String.fromCharCode.apply(null, iv));
    const base64HMAC = btoa(String.fromCharCode.apply(null, hmacHashUint8Array));

    localStorage.setItem('lastBase64IV', base64IV);

    const payload = {
        receiver_id: peer_id,
        message_text: encryptedMessage,
        iv: base64IV,
        hmac: base64HMAC,
    };

    fetch('/send_message', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
    })
    .then(response => {
        if (!response.ok) {
            // If the server response is not OK, throw an error
            throw new Error('Network response was not ok');
        }
        return response.json(); // Parse JSON response from the server
    })
    .then(data => {
        document.getElementById('messageInput').value = ''; // Clear the input after sending
    })
    .catch(error => {
        console.error('Error sending message:', error); // Log any errors
    });
}

// Refresh Keys function placeholder
function refreshKeys() {
    console.log('Refresh keys functionality will be implemented here.');
}

// Populate users function
function populateUsers(users) {
    const userListDropdown = document.getElementById("userList");
    users.forEach(user => {
        const option = new Option(user[1], user[0]); // username as text, user_id as value
        userListDropdown.add(option);
    });
}

// Fetch users from server
$(document).ready(function() {
    fetch('/users')
        .then(response => response.json())
        .then(data => {
            data.users.forEach(user => {
                userInfo[user[0]] = user[1]; // Map user_id to username
            });
            console.log(userInfo);
            populateUsers(data.users);
        })
        .catch(error => console.error('Error fetching user info:', error));
});

// Clear chat box
function clearChatBox() {
    document.getElementById('messages').innerHTML = '';
}

// Fetch messages from server
function fetchMessages() {
    if (peer_id === -1) return; // Exit if no peer selected

    fetch(`/fetch_messages?last_message_id=${lastMessageId}&peer_id=${peer_id}`)
        .then(response => response.json())
        .then(data => {
            data.messages.forEach(message => {
                // Check if message_text and iv are defined
                if (typeof message.message_text === 'undefined' || typeof message.iv === 'undefined') {
                    console.error('Undefined message text or iv');
                    return; // Skip this message
                }

                try {
                    const decodedIv = base64ToUint8Array(message.iv);
                    const decodedMessageText = base64ToUint8Array(message.message_text);

                    console.log(message.hmac);
                    // const decodedHMAC = base64ToUint8Array(message.hmac);

                    console.log('Decoded IV:', decodedIv);
                    console.log('Decoded message:', decodedMessageText.buffer);
                    // console.log('Decoded HMAC:', decodedHMAC);
                    
                    // if (lastMessageId === 0) {
                    //     localStorage.setItem('lastReceivedIV', message.iv);
                    // } else {
                    //     const lastReceivedIV = localStorage.getItem('lastReceivedIV');
                    //     const lastReceivedIVUint8Array = base64ToUint8Array(lastReceivedIV);

                    //     if (byteArrayToBigInt(lastReceivedIVUint8Array) >= byteArrayToBigInt(decodedIv)) {
                    //         console.error('error');
                    //         return;
                    //     }

                    //     localStorage.setItem('lastReceivedIV', message.iv);
                    // }

                    decryptMessage(decodedMessageText.buffer, decodedIv)
                        .then(decryptedMessage => {
                            message.message_text = decryptedMessage;
                            displayMessage(message);
                        })
                        .catch(error => console.error('Error decrypting message:', error));

                } catch (error) {
                    console.error('Error decoding base64:', error);
                }
                lastMessageId = message.message_id;
            });
        })
        .catch(error => console.error('Error fetching messages:', error));
}

function byteArrayToBigInt(byteArray) {
    let value = BigInt(0);
    for (let i = 0; i < byteArray.length; i++) {
        value = (value * BigInt(256)) + BigInt(byteArray[i]);
    }
    return value;
}

function base64ToUint8Array(base64) {
    const binaryString = window.atob(base64);
    const len = binaryString.length;
    let bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
        bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes;
}

// Display a single message
function displayMessage(message) {
    const messagesContainer = document.getElementById('messages');
    const messageElement = document.createElement('div');

    // Determine sender and receiver strings
    const sender = message.sender_id == myID ? "me" : (userInfo[message.sender_id] || `User ${message.sender_id}`);
    const receiver = message.receiver_id == myID ? "me" : (userInfo[message.receiver_id] || `User ${message.receiver_id}`);

    messageElement.textContent = `From ${sender} to ${receiver}: ${message.message_text}`;
    messagesContainer.appendChild(messageElement);
}

// Periodically fetch new messages every second
setInterval(fetchMessages, 1000);

// Erase Chat function using fetch API
function eraseChat() {
    if (peer_id === -1) return; // Exit if no peer selected
    if (!confirm('Are you sure you want to erase the chat with '+userInfo[peer_id]+'?')) return; // Confirmation before erasing

    fetch(`/erase_chat`, {
        method: 'POST',  // A REST API should use POST if it leads to modifications
        headers: {
            'Content-Type': 'application/json', 
        },
        body: JSON.stringify({ peer_id: peer_id })
    })
    .then(response => {
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        return response.json(); // Assuming the server responds with JSON
    })
    .then(data => {
        console.log('Chat erased:', data);
        clearChatBox(); // Clear the chat display
    })
    .catch(error => {
        console.error('Error erasing chat:', error);
    });
}

</script>
</body>
</html>
